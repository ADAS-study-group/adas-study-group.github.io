<!DOCTYPE html><html lang="en" mode="dark" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>사용자 Layer 생성 | ADAS Study Group Tech Blog</title><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="사용자 Layer 생성" /><meta name="author" content="Jo, SeungHyeon" /><meta property="og:locale" content="en_US" /><meta name="description" content="새로운 Layer 추가 사전에 OpenEmbedded Meta-data Index http://layers.openembedded.org 에서 이미 이용 가능한 비슷한 Layer가 있는지 확인하는 것이 좋다. 필요한 Layer를 찾을 수 없으면 다음 단계로 Directory를 생성한다. meta- 로 시작는 것을 추천한다. Layer의 환경설정 file은 모든 Layer에서 필요하고, conf/layer.conf file로 되어 있다. 이 file은 Text editor를 사용해 수작업으로 만들 수도 있지만, 다음과 같이 Poky에서 제공하는 Script로 만들 수 있다. Creating Layer 1 2 3 cd ~/poky source oe-init-build-env bitbake-layers create-layer ../poky/meta-mylayer Script로 Layer를 생성하기 위해 Layer 우선순위 값 입력하고 샘플 내용 관련된 질문에 답을 입력한다. 예시 사용자 Layer를 작업하기 위해 다른 Layer를 추가 할 필요가 있을 때, 사용하는 변수 LAYERVERSION 하나의 숫자로 Layer의 Version을 표시할 때, 사용하는 선택적 변수다. 이 변수는 LAYERDEPENDS 변수에서 Layer 특정 Version에 의존성을 걸기 위해 사용하고, LAYERVERSION_newlayer = “1” 와 같이 Layer의 이름에 접미사를 붙여 사용한다. LAYERDEPENDS 공백으로 분리 Recipe의 의존성을 걸기 위해 Layer목록을 가진다. 선택적으로 otherlayer:2 와 같이 Layer의 이름 끝에 콜론을 추가해 의존성과 같이 Layer Version을 적시 할 수도 있다. 이 변수도 특정 Layer의 이름과 함께, LAYERDEPENDS_newlayer = “otherlayer” 와 같이 Layer의 이름에 접미사를 붙여 사용한다. 의존성을 만족하지 않거나 Version 정보가 맞지 않으면 Error가 발생 Layer에서 Metadata 추가(Layer 구조의 기반을 만들고 확장하는 방법) Layer을 사용하는 목적은 bitbake database에 meta-data를 추가하거나 변경하기 위함 많이 추가하는 것은 Application, Library, 혹은 Service server와 같이 Project와 관련된 것 새로운 특징을 추가 하는 것보다 SSH서버를 위한 초기 Network 값 또는 Booting 화면의 예와 같이 사용자가 필요로 하는 기존 설정을 변경하는 것이 더 자주 이뤄 진다. 기존의 것을 바꾸기 위해 새로운 Layer, Recipe, Image, .bbappend file 들에서 Meta-data file 여러 종류를 포함할 수 있다. 앞에서 사용한 Script는 두 개의 예제 file과 새로운 Layer를 만들 때 사용됐다. 첫 번째 example_0.1.bb는 Recipe의 예제다. Example_0.1.bbappend는 example_0.1.bb를 포함하고 내용을 수정할 때 사용하는 bbappend의 예제이다. meta-yocto-bsp 또는 meta-yocto에 따른 여러 .bbappend 예제가 있고, 많이 사용하는 것들 추후 정리 (12장) Image 생성 Image file은 정해진 방식에서 목적을 가지고 설정된 Package의 집합 기존 Image에 필요한 Package를 추가하고 환경설정을 덮어씌운 새로운 Image를 만들 수 있다. 또한 처음부터 새로운 Image를 만들 수도 있다. Image를 필요에 맞게 만들고 작은 수정 했 때 그 코드를 재사용하는 것이 매우 편리 이는 코드 유지 보수를 쉽게 만들고 기능상 차이점은 강조됨 예시 core-image-sato image에서 application을 포함하기 원하고 하나의 Image 특징을 제거하기 원한다면 다음 code를 recipes-my/images/my-image-sato.bb에 추가해 image를 생성할 수 있다. require recipes-sato/image/core-image-sato.bb IMAGE_FEATURES_remove = &quot;splash&quot; CORE_IMAGE_EXTRA_INSTALL += &quot;myapp&quot; 처음부터 Image를 생성할 필요가 있을 때, 쉽고 유용하게 사용되는 Image 특징의 집합을 제공하는 core-image class를 사용해 그런 작업을 빠르게 할 수 있다. 예를 들면 recipe-my/images/my-image-nano.bb에서 Image는 다음과 같이 구성됨 inherit core-image IMAGE_FEATURES += &quot;ssh-server-openssh splash&quot; CORE_IMAGE_EXTRA_INSTALL += &quot;nano&quot; Append 연산자(+=)는 새로운 IMAGE_FEATURE 변수가 build/conf/local.conf에 추가될 수 있게 보장하기 위해 사용됨 core-image class를 상속받을 때 이미지 생성과 IMAGE_FEATURES 변수를 쉽게 추가하고 코드 중복을 피하게 CORE_IMAGE_EXTRA_INSTALL 변수를 사용해 Image에 추가 Package를 포함한다. IMAGE_INSTALL 변수는 CORE_IMAGE_EXTRA_INSTALL을 추가하고 IMAGE_FEATURES에 관련된 Package를 Root file system에 생성한다. IMAGE_FEATURES 추가가능 features allow-empty-password Dropbear와 OpenSSH에서 빈 호를 사용해 root 계정으로 로그인 할 수 있게 허용한다. dpg-pkgs Image에 설치된 모든 Package의 Debug symbol package를 설치한다. debug-tweaks 개발에 필요한 Package를 설치해 Image를 만든다. dev-pkgs Image에 설치된 모든 Package의 개발 Package (Header와 추가 Library)를 설치한다. eclipse-debug Eclipse IDE에서 원격 Debugging을 지원하게 한다. empty-root-password root 암호를 빈 문자열로 설정한다. Hwcodecs HW 가속되는 Codec을 설치한다. nfs-server NFS server를 설치한다. package-management Package 관리도구를 설치하고 Package 관리 Database를 가진다. perf perf, systemtap, LTTng 같은 Profiling 도구를 설치한다. post-install-logging Target system에서 image를 처음으로 booting할 때 post-install script 실행을 /var/log/postinstall.log file에 저장한다. ptest-pkgs ptest 가 활성화된 모든 Recipe의 ptest Package를 설치한다. read-only-rootfs Root file system이 읽기만 가능하게 Image를 만든다. splash Booting하는 동안 Splash 화면이 보이게 한다. ssh-server-dropbear Dropbear SSH server 를 설치한다. ssh-server-openssh Dropbear보다 많은 기능을 가진 OpenSSH server를 설치한다. staticdev-pkgs Image에서 설치된 모든 Package의 정적 개발 Package (즉, *.a file들을 포함한 static library)를 설치한다. tools-debug strace와 gdb 같은 debugging도구를 설치한다. tools-sdk Device에서 실행하는 전체 SDK를 설치한다. Tools-testapps Device test 도구를 설치한다. (e.g. touch screen debugging) x11 X server를 설치한다. x11-base 최소 환경을 가진 X server를 설치한다. x11-sato OpenedHand Sato 환경을 설치한다. Package Recipe 추가 Package Recipe는 BitBake가 Application, Kernel module, 또는 Project 에서 제공하는 SW를 Download, 압축풀기, Compile, 설치하는 방법을 제시한다. Poky는 Autotools, Cmake, QMake를 기반으로 하는 Project로 가장 흔한 개발 도구를 추상화한 여러 Class를 가지고 있다. Poky에 있는 Class의 목록은 http://www.yoctoproject.org/docs/2.4/ref-manual/ref-manual.html 에서 볼 수 있다. Compile과 설치 작업을 하는 간단한 Recipe 예제는 다음과 같다. do_compile과 do_install code 영역은 build와 결과 binary를 ${D}로 언급된 Target directory에 설치 하기 위한 shell script 명령어를 사용한다. Autotools기반 Project의 경우, 다음과 같이 poky/meta/recipecore/dbus-wait/dbus-wait_git.bb의 일부 축약된 Recipe를 보면 알 수 있듯이 autotools Class를 사용해 많은 Code 중복을 피할 수 있다. DESCRIPTION = &quot;A simple tool to wait for a specific signal over DBus&quot; ... inherit autotools Class를 상속받는 단순 행위는 다음 작업을 하기 위해 요구되는 모든 Code를 제공한다. Configure script code와 결과물 update libtool script update Configure script 실행 make 실행 make install 실행 이와 같은 개념은 CMake와 QMake의 경우와 같이 다른 Build 도구에도 적용됨 지원되는 Class의 수는 계속 늘어나고 매 release시에 포함된다. recipetool을 사용해 기본 Package Recipe 자동 생성 recipetool 을 사용하면 Source code file을 기반으로 기본 Recipe를 쉽게 만들 수 있다. 압축을 풀고 Source file을 지정할 수 있으면 recipetool은 Recip를 만들고 신규 Recipe file에 모든 file에 모든 build 정보를 자동으로 설정 autotools로 build하는 Application recipetools을 사용해 기본 Recipe를 생성하면 Build 의존성을 가진 Recipe를 생성한다. 이 Recipe는 autotools Class를 상속하고 License 요구사항과 Checksum을 설정한다. recipetool은 내용의 이해를 돕기 위해 주석을 함께 포함한 Recipe를 생성한다. 모든 주석은 Meta-layer에 Recipe file을 통합할 때 삭제할 수 있다. https://github.com/OSSystems/bbexample 에 있는 bbexample을 사용해 Recipe를 생성 1 2 source oe-init-build-env build recipetool create -V 1.0 https://github.com/OSSystems/bbexample recipetool은 URL에서 Source code를 Download해 내용을 분석하고 bbexample_git.bb file을 생성한다. Source code 기반으로 아래 Recipe file을 생성한다. recipetool이 기본 Recipe를 생성하더라도 최종 사용할 Recipe로 완벽하지 않다. Compile option, 추가 Meta-data 정보 등을 확인해야 한다. bbexample_git.bb file은 recipetool을 실행한 Directory에 생성되기 때문에 meta-newlayer/recipe-mine/bbexample/bbexample_git.bb처럼 필요한 위치에 file을 복사해서 사용해야 한다. 복사하고 나면 bitbake를 사용해 build할 수 있다. 신규 Machine 추가 Poky에서 사용하기 위해 새로운 Machine을 만드는 것은 간단하다. 본질적으로 작업을 위한 Machine에 필요한 정보를 제공한다. Boot loader, kernel, HW 지원 Driver는 BSP layer에서 Board에 통합하기 위해 시작 전에 점검한다. Yocto Project는 현재 사용하는 Embedded Architecture의 대부분을 지원 Machine 정의에서 사용되는 변수 TARGET_ARCH ARM과 i586과 같은 Machine Architecture를 설정 PREFERRED_PROVIDER_virtual/kernel 특정한 Kernel을 사용하는 경우 기본 Kernel (linux-yocto) 덮어쓴다. SERIAL_CONSOLES Serial console과 속도를 정의 MACHINE_FEATURES 필요한 SW stack이 기본 Image에 포함되게 HW특성을 정의 KERNEL_IMAGETYPE zImage나 uImage 같은 Kernel image 종류를 선택하기 위해 사용 IMAGE_FSTYPES tar.gz, ext4, ubifs 같은 일반적인 File system image 종류를 선택 meta-yocto-bsp/conf/machine의 Poky source code에서 Machine file들의 예제를 볼 수 있다. 새로운 Machine을 만들 때, 특히 MACHINE_FEATURES 에서 지원하는 기술을 잘 살펴 봐야 한다. 이런 방법으로 특성을 지원하기 위해 필요한 SW가 Image에 설치된다. MACHINE_FEATURES에 대해 이용 가능한 값 acpi HW가 ACPI(x86/x86_64에 대해서만)를 구비 alsa HW가 ALSA Audio Driver를 구비 apm HW가 APM(또는 APM emulation)을 사용 bluetooth HW가 통합된 Bluetooth를 구비 efi EFI로 Booting 할 수 있게 지원 ext2 HW가 HDD 또는 Micro drive를 구비 IRDA HW가 IrDA를 지원 keyboard HW가 Keyboard를 구비 pcbios BIOS로 Booting할 수 있게 지원 pci HW가 PCI bus를 구비 pcmcia HW가 PCMCIA 또는 CompactFlash Socket을 구비 phone Mobile phone(음성)을 지원 qvga QVGA(320x240) Display를 지원 rtc Real time clock을 지원 screen HW가 화면을 구비 serial HW가 Serial(일반적으로 RS232)을 지원 touchscreen HW가 Touch screen을 구비 usbgadget HW가 USB gadget driver와 호환 usbhost HW가 USB host와 호환 vflat FAT file system을 지원 wifi HW가 통합된 wifi를 구비 Machine에 Image 배치 BSP Layer 개발이 끝날 때 까지 자주 잊는 것 중 하나는 Machine에 바로 사용할 수 있는 Image를 생성하는 것 사용하는 Image의 종류는 Processor, Board 에 있는 주변장치, Project 제약 등과 같이 여러 경우에 따라 달라진다. 저장소에 직접 사용하기 위해 가장 많이 사용하는 Image 종류는 Partition된 Image Yocto Project는 이런 Image를 생성할 때 유연하게 사용할 수 있는 wic도구가 있다. Target image layer을 정의하는데 많이 사용하는 언어로 작성된 Template file(wks)을 기반으로 Partition된 Image를 생성할 수 있다. 이것은 http://www.yoctoproject.org/docs/2.4/ref-manual/ref-manual.html#openebedded-kickstart-wks-reference 를 참고해 작성 wks file은 Meta-data의 wic directory에 있다. 다른 Image layout을 지정할 수 있도록 Directory에 여러 개의 file 갖고 있는 것이 일반적이다. Machine과 일치하는 Layout을 선택하는 것이 중요 예시 두 개의 Partition으로 SD card에 SPL과 U-Boot를 사용하는 i.MX 기반 Machine을 고려할 때 하나는 Boot file용이고 다른 하나는 Root file system용이다. 각 wks file은 다음과 같다. wic 기반 Image를 생성 할 수 있게 하려면 IMAGE_FSTYPES에 추가해야 한다. WKS_FILE 변수에 wks file을 설정해 사용할 수 있다. Custom 배포 배포의 생성은 단순함과 복잡함이 섞여 있다. 배포 file을 만드는 절차는 매우 쉽다. 배포 환경설정은 Poky가 사용하는 방식에 큰 영향을 주고, 사용한 Option에 따라 이전에 Build된 Binary에 호환성을 갖지 않는 데 영향을 줄 수 있다. 배포는 Tool chain version, Graphic Backend, OpenGL 지원 등과 같은 전역 Option을 정의한다. Poky에서 제공하는 기본 설정을 사용하면 간단한 배포를 만들 수 있지만, 사용자의 요구 사항을 모두 만족시킬 수는 없다. 일반적으로 Poky의 작은 Option 집합을 의도적으로 변화 시킨다. E.g. Framebuffer를 사용하게 X11 지원을 제거 Poky 배포의 재사용과 필요한 변수를 덮어 쓰는 것을 쉽게 수행할 수 있다. E.g. Sample 배포는 다음 &lt;layer&gt;/conf/distro/mydistro.conf file처럼 표현한다. 생성된 배포를 사용하기 위해 build/conf/local.conf에 다음 code 한 부분만 추가하면 된다. DISTRO = “mydistro” DISTRO_FEATURES 변수는 Recipe를 설정하고 Package를 Image에 설치하는 방법에 영향을 미친다. E.g. 어떤 Machine과 Image에서 Sound를 사용하기 원하면 alsa 기능이 지원돼야 한다. DISTRO_FEATURE에서 지원하는 기능들 alsa ALSA를 지원 (지원하면 OSS 호환 Kernel module이 설치돼 있다.) api-documentation Recipe를 Build하는 동안 API 문서를 생성 bluetooth Bluetooth를 지원(통합된 Bluetooth만 해당) Bluz5 핵심 Bluetooth layer와 Protocol 지원을 제공하는 BlueZ version 5를 포함 cramsfs CramFS를 지원 directfb DirectFB를 지원 ext2 File을 저장하게 내장 Harddisk / Micro driver를 가진 Device를 지원하기 위한 도구를 포함(Flash만 지원하는 Device 대신) ipsec IPSec를 지원 Ipv6 IPv6를 지원 irda IrDA를 지원 keyboard Keyboard를 지원(e.g. Keymap이 booting하는 동안 Loading된다.) ldconfig Target에서 ldconfig와 ld.so.conf를 지원 nfs NFS client를 지원한다. (Device에서 NFS를 Mount 하기 위해) opengl 2차원, 3차원 Graphic을 Rendering하기 위해 사용되는 Cross language, Multi-platform application programming interface를 지원하는 OpenGL을 지원 pci PCI bus를 지원 pcmcia PCMCIA/CompactFlash를 지원 ppp PPP Dial up을 지원 ptest 개별 Recipe에서 지원하는 Package test를 Build smbfs SMB Network client를 지원 (Device에서 Microsoft window를 SAMBA로 Mount하기 위해) systemmd Service를 병렬로 시작하는 init을 완벽히 대체하며, Shell overhead 줄이고 다른 특징들을 갖는 초기화 관리자를 지원한다. 이 초기 관리자는 많은 배포판에서 사용한다. usbgadget USB gadget device를 지원(USB networking / serial / 저장장치를 위해) usbhost USB host를 지원(외부 keyboard, Mouse, 저장장치, Network 등을 연결할 수 있게) wayland Wayland Display server protocol과 Library를 지원 wifi Wifi를 지원 (통합된 wifi만 해당) x111 X server와 Library를 포함 MACHINE_FEATURES와 DISTRO_FEATURES 비교 DISTRO_FEATURES와 MACHINE_FEATURE 모두 최종 System에서 사용 수 있는 기능을 제공 Machine이 기능을 지원할 때 이 최종 System에 의해 지원되는 것을 시사하지는 않는다. 사용하는 배포판에서 해당 기능을 위한 근본적인 기반을 제공해야 하기 때문 Machine이 Wifi를 지원하지만, 배포판이 지원하지 않으면 OS에서 사용하는 Application은 Wifi 지원 기능이 비활성화된 상태로 Build될 것 그 결과 Wifi 없는 System이 될 것 배포판에서 Wifi가 지원되고 Machine이 지원하지 않으면 OS와 Module이 Wifi가 활성화 되어 있더라도 Wifi에 필요한 Module과 Application은 이 Machine이 Build된 Image에 설치되지 않을 것 변수의 범위 BitBake Meta-data는 수천 가지 변수가 있지만 이 변수는 자신이 정의된 곳에 영향을 미치고 해당 영역에서 이용 가능 기본적으로 변수에는 다음과 같은 두 가지 종류가 있다. 환경설정 파일에 정의된 변수는 모든 Recipe에서 전역 변수 주된 환경설정 File의 Parsing 순서는 다음과 같다. build/conf/local.conf &lt;layer&gt;/conf/machines/&lt;machine&gt;.conf &lt;layer&gt;/conf/distro/&lt;distro&gt;.conf Recipe file에 정의된 변수는 그 작업이 진행되는 동안 특정 Recipe에서만 사용할 수 있는 지역 변수" /><meta property="og:description" content="새로운 Layer 추가 사전에 OpenEmbedded Meta-data Index http://layers.openembedded.org 에서 이미 이용 가능한 비슷한 Layer가 있는지 확인하는 것이 좋다. 필요한 Layer를 찾을 수 없으면 다음 단계로 Directory를 생성한다. meta- 로 시작는 것을 추천한다. Layer의 환경설정 file은 모든 Layer에서 필요하고, conf/layer.conf file로 되어 있다. 이 file은 Text editor를 사용해 수작업으로 만들 수도 있지만, 다음과 같이 Poky에서 제공하는 Script로 만들 수 있다. Creating Layer 1 2 3 cd ~/poky source oe-init-build-env bitbake-layers create-layer ../poky/meta-mylayer Script로 Layer를 생성하기 위해 Layer 우선순위 값 입력하고 샘플 내용 관련된 질문에 답을 입력한다. 예시 사용자 Layer를 작업하기 위해 다른 Layer를 추가 할 필요가 있을 때, 사용하는 변수 LAYERVERSION 하나의 숫자로 Layer의 Version을 표시할 때, 사용하는 선택적 변수다. 이 변수는 LAYERDEPENDS 변수에서 Layer 특정 Version에 의존성을 걸기 위해 사용하고, LAYERVERSION_newlayer = “1” 와 같이 Layer의 이름에 접미사를 붙여 사용한다. LAYERDEPENDS 공백으로 분리 Recipe의 의존성을 걸기 위해 Layer목록을 가진다. 선택적으로 otherlayer:2 와 같이 Layer의 이름 끝에 콜론을 추가해 의존성과 같이 Layer Version을 적시 할 수도 있다. 이 변수도 특정 Layer의 이름과 함께, LAYERDEPENDS_newlayer = “otherlayer” 와 같이 Layer의 이름에 접미사를 붙여 사용한다. 의존성을 만족하지 않거나 Version 정보가 맞지 않으면 Error가 발생 Layer에서 Metadata 추가(Layer 구조의 기반을 만들고 확장하는 방법) Layer을 사용하는 목적은 bitbake database에 meta-data를 추가하거나 변경하기 위함 많이 추가하는 것은 Application, Library, 혹은 Service server와 같이 Project와 관련된 것 새로운 특징을 추가 하는 것보다 SSH서버를 위한 초기 Network 값 또는 Booting 화면의 예와 같이 사용자가 필요로 하는 기존 설정을 변경하는 것이 더 자주 이뤄 진다. 기존의 것을 바꾸기 위해 새로운 Layer, Recipe, Image, .bbappend file 들에서 Meta-data file 여러 종류를 포함할 수 있다. 앞에서 사용한 Script는 두 개의 예제 file과 새로운 Layer를 만들 때 사용됐다. 첫 번째 example_0.1.bb는 Recipe의 예제다. Example_0.1.bbappend는 example_0.1.bb를 포함하고 내용을 수정할 때 사용하는 bbappend의 예제이다. meta-yocto-bsp 또는 meta-yocto에 따른 여러 .bbappend 예제가 있고, 많이 사용하는 것들 추후 정리 (12장) Image 생성 Image file은 정해진 방식에서 목적을 가지고 설정된 Package의 집합 기존 Image에 필요한 Package를 추가하고 환경설정을 덮어씌운 새로운 Image를 만들 수 있다. 또한 처음부터 새로운 Image를 만들 수도 있다. Image를 필요에 맞게 만들고 작은 수정 했 때 그 코드를 재사용하는 것이 매우 편리 이는 코드 유지 보수를 쉽게 만들고 기능상 차이점은 강조됨 예시 core-image-sato image에서 application을 포함하기 원하고 하나의 Image 특징을 제거하기 원한다면 다음 code를 recipes-my/images/my-image-sato.bb에 추가해 image를 생성할 수 있다. require recipes-sato/image/core-image-sato.bb IMAGE_FEATURES_remove = &quot;splash&quot; CORE_IMAGE_EXTRA_INSTALL += &quot;myapp&quot; 처음부터 Image를 생성할 필요가 있을 때, 쉽고 유용하게 사용되는 Image 특징의 집합을 제공하는 core-image class를 사용해 그런 작업을 빠르게 할 수 있다. 예를 들면 recipe-my/images/my-image-nano.bb에서 Image는 다음과 같이 구성됨 inherit core-image IMAGE_FEATURES += &quot;ssh-server-openssh splash&quot; CORE_IMAGE_EXTRA_INSTALL += &quot;nano&quot; Append 연산자(+=)는 새로운 IMAGE_FEATURE 변수가 build/conf/local.conf에 추가될 수 있게 보장하기 위해 사용됨 core-image class를 상속받을 때 이미지 생성과 IMAGE_FEATURES 변수를 쉽게 추가하고 코드 중복을 피하게 CORE_IMAGE_EXTRA_INSTALL 변수를 사용해 Image에 추가 Package를 포함한다. IMAGE_INSTALL 변수는 CORE_IMAGE_EXTRA_INSTALL을 추가하고 IMAGE_FEATURES에 관련된 Package를 Root file system에 생성한다. IMAGE_FEATURES 추가가능 features allow-empty-password Dropbear와 OpenSSH에서 빈 호를 사용해 root 계정으로 로그인 할 수 있게 허용한다. dpg-pkgs Image에 설치된 모든 Package의 Debug symbol package를 설치한다. debug-tweaks 개발에 필요한 Package를 설치해 Image를 만든다. dev-pkgs Image에 설치된 모든 Package의 개발 Package (Header와 추가 Library)를 설치한다. eclipse-debug Eclipse IDE에서 원격 Debugging을 지원하게 한다. empty-root-password root 암호를 빈 문자열로 설정한다. Hwcodecs HW 가속되는 Codec을 설치한다. nfs-server NFS server를 설치한다. package-management Package 관리도구를 설치하고 Package 관리 Database를 가진다. perf perf, systemtap, LTTng 같은 Profiling 도구를 설치한다. post-install-logging Target system에서 image를 처음으로 booting할 때 post-install script 실행을 /var/log/postinstall.log file에 저장한다. ptest-pkgs ptest 가 활성화된 모든 Recipe의 ptest Package를 설치한다. read-only-rootfs Root file system이 읽기만 가능하게 Image를 만든다. splash Booting하는 동안 Splash 화면이 보이게 한다. ssh-server-dropbear Dropbear SSH server 를 설치한다. ssh-server-openssh Dropbear보다 많은 기능을 가진 OpenSSH server를 설치한다. staticdev-pkgs Image에서 설치된 모든 Package의 정적 개발 Package (즉, *.a file들을 포함한 static library)를 설치한다. tools-debug strace와 gdb 같은 debugging도구를 설치한다. tools-sdk Device에서 실행하는 전체 SDK를 설치한다. Tools-testapps Device test 도구를 설치한다. (e.g. touch screen debugging) x11 X server를 설치한다. x11-base 최소 환경을 가진 X server를 설치한다. x11-sato OpenedHand Sato 환경을 설치한다. Package Recipe 추가 Package Recipe는 BitBake가 Application, Kernel module, 또는 Project 에서 제공하는 SW를 Download, 압축풀기, Compile, 설치하는 방법을 제시한다. Poky는 Autotools, Cmake, QMake를 기반으로 하는 Project로 가장 흔한 개발 도구를 추상화한 여러 Class를 가지고 있다. Poky에 있는 Class의 목록은 http://www.yoctoproject.org/docs/2.4/ref-manual/ref-manual.html 에서 볼 수 있다. Compile과 설치 작업을 하는 간단한 Recipe 예제는 다음과 같다. do_compile과 do_install code 영역은 build와 결과 binary를 ${D}로 언급된 Target directory에 설치 하기 위한 shell script 명령어를 사용한다. Autotools기반 Project의 경우, 다음과 같이 poky/meta/recipecore/dbus-wait/dbus-wait_git.bb의 일부 축약된 Recipe를 보면 알 수 있듯이 autotools Class를 사용해 많은 Code 중복을 피할 수 있다. DESCRIPTION = &quot;A simple tool to wait for a specific signal over DBus&quot; ... inherit autotools Class를 상속받는 단순 행위는 다음 작업을 하기 위해 요구되는 모든 Code를 제공한다. Configure script code와 결과물 update libtool script update Configure script 실행 make 실행 make install 실행 이와 같은 개념은 CMake와 QMake의 경우와 같이 다른 Build 도구에도 적용됨 지원되는 Class의 수는 계속 늘어나고 매 release시에 포함된다. recipetool을 사용해 기본 Package Recipe 자동 생성 recipetool 을 사용하면 Source code file을 기반으로 기본 Recipe를 쉽게 만들 수 있다. 압축을 풀고 Source file을 지정할 수 있으면 recipetool은 Recip를 만들고 신규 Recipe file에 모든 file에 모든 build 정보를 자동으로 설정 autotools로 build하는 Application recipetools을 사용해 기본 Recipe를 생성하면 Build 의존성을 가진 Recipe를 생성한다. 이 Recipe는 autotools Class를 상속하고 License 요구사항과 Checksum을 설정한다. recipetool은 내용의 이해를 돕기 위해 주석을 함께 포함한 Recipe를 생성한다. 모든 주석은 Meta-layer에 Recipe file을 통합할 때 삭제할 수 있다. https://github.com/OSSystems/bbexample 에 있는 bbexample을 사용해 Recipe를 생성 1 2 source oe-init-build-env build recipetool create -V 1.0 https://github.com/OSSystems/bbexample recipetool은 URL에서 Source code를 Download해 내용을 분석하고 bbexample_git.bb file을 생성한다. Source code 기반으로 아래 Recipe file을 생성한다. recipetool이 기본 Recipe를 생성하더라도 최종 사용할 Recipe로 완벽하지 않다. Compile option, 추가 Meta-data 정보 등을 확인해야 한다. bbexample_git.bb file은 recipetool을 실행한 Directory에 생성되기 때문에 meta-newlayer/recipe-mine/bbexample/bbexample_git.bb처럼 필요한 위치에 file을 복사해서 사용해야 한다. 복사하고 나면 bitbake를 사용해 build할 수 있다. 신규 Machine 추가 Poky에서 사용하기 위해 새로운 Machine을 만드는 것은 간단하다. 본질적으로 작업을 위한 Machine에 필요한 정보를 제공한다. Boot loader, kernel, HW 지원 Driver는 BSP layer에서 Board에 통합하기 위해 시작 전에 점검한다. Yocto Project는 현재 사용하는 Embedded Architecture의 대부분을 지원 Machine 정의에서 사용되는 변수 TARGET_ARCH ARM과 i586과 같은 Machine Architecture를 설정 PREFERRED_PROVIDER_virtual/kernel 특정한 Kernel을 사용하는 경우 기본 Kernel (linux-yocto) 덮어쓴다. SERIAL_CONSOLES Serial console과 속도를 정의 MACHINE_FEATURES 필요한 SW stack이 기본 Image에 포함되게 HW특성을 정의 KERNEL_IMAGETYPE zImage나 uImage 같은 Kernel image 종류를 선택하기 위해 사용 IMAGE_FSTYPES tar.gz, ext4, ubifs 같은 일반적인 File system image 종류를 선택 meta-yocto-bsp/conf/machine의 Poky source code에서 Machine file들의 예제를 볼 수 있다. 새로운 Machine을 만들 때, 특히 MACHINE_FEATURES 에서 지원하는 기술을 잘 살펴 봐야 한다. 이런 방법으로 특성을 지원하기 위해 필요한 SW가 Image에 설치된다. MACHINE_FEATURES에 대해 이용 가능한 값 acpi HW가 ACPI(x86/x86_64에 대해서만)를 구비 alsa HW가 ALSA Audio Driver를 구비 apm HW가 APM(또는 APM emulation)을 사용 bluetooth HW가 통합된 Bluetooth를 구비 efi EFI로 Booting 할 수 있게 지원 ext2 HW가 HDD 또는 Micro drive를 구비 IRDA HW가 IrDA를 지원 keyboard HW가 Keyboard를 구비 pcbios BIOS로 Booting할 수 있게 지원 pci HW가 PCI bus를 구비 pcmcia HW가 PCMCIA 또는 CompactFlash Socket을 구비 phone Mobile phone(음성)을 지원 qvga QVGA(320x240) Display를 지원 rtc Real time clock을 지원 screen HW가 화면을 구비 serial HW가 Serial(일반적으로 RS232)을 지원 touchscreen HW가 Touch screen을 구비 usbgadget HW가 USB gadget driver와 호환 usbhost HW가 USB host와 호환 vflat FAT file system을 지원 wifi HW가 통합된 wifi를 구비 Machine에 Image 배치 BSP Layer 개발이 끝날 때 까지 자주 잊는 것 중 하나는 Machine에 바로 사용할 수 있는 Image를 생성하는 것 사용하는 Image의 종류는 Processor, Board 에 있는 주변장치, Project 제약 등과 같이 여러 경우에 따라 달라진다. 저장소에 직접 사용하기 위해 가장 많이 사용하는 Image 종류는 Partition된 Image Yocto Project는 이런 Image를 생성할 때 유연하게 사용할 수 있는 wic도구가 있다. Target image layer을 정의하는데 많이 사용하는 언어로 작성된 Template file(wks)을 기반으로 Partition된 Image를 생성할 수 있다. 이것은 http://www.yoctoproject.org/docs/2.4/ref-manual/ref-manual.html#openebedded-kickstart-wks-reference 를 참고해 작성 wks file은 Meta-data의 wic directory에 있다. 다른 Image layout을 지정할 수 있도록 Directory에 여러 개의 file 갖고 있는 것이 일반적이다. Machine과 일치하는 Layout을 선택하는 것이 중요 예시 두 개의 Partition으로 SD card에 SPL과 U-Boot를 사용하는 i.MX 기반 Machine을 고려할 때 하나는 Boot file용이고 다른 하나는 Root file system용이다. 각 wks file은 다음과 같다. wic 기반 Image를 생성 할 수 있게 하려면 IMAGE_FSTYPES에 추가해야 한다. WKS_FILE 변수에 wks file을 설정해 사용할 수 있다. Custom 배포 배포의 생성은 단순함과 복잡함이 섞여 있다. 배포 file을 만드는 절차는 매우 쉽다. 배포 환경설정은 Poky가 사용하는 방식에 큰 영향을 주고, 사용한 Option에 따라 이전에 Build된 Binary에 호환성을 갖지 않는 데 영향을 줄 수 있다. 배포는 Tool chain version, Graphic Backend, OpenGL 지원 등과 같은 전역 Option을 정의한다. Poky에서 제공하는 기본 설정을 사용하면 간단한 배포를 만들 수 있지만, 사용자의 요구 사항을 모두 만족시킬 수는 없다. 일반적으로 Poky의 작은 Option 집합을 의도적으로 변화 시킨다. E.g. Framebuffer를 사용하게 X11 지원을 제거 Poky 배포의 재사용과 필요한 변수를 덮어 쓰는 것을 쉽게 수행할 수 있다. E.g. Sample 배포는 다음 &lt;layer&gt;/conf/distro/mydistro.conf file처럼 표현한다. 생성된 배포를 사용하기 위해 build/conf/local.conf에 다음 code 한 부분만 추가하면 된다. DISTRO = “mydistro” DISTRO_FEATURES 변수는 Recipe를 설정하고 Package를 Image에 설치하는 방법에 영향을 미친다. E.g. 어떤 Machine과 Image에서 Sound를 사용하기 원하면 alsa 기능이 지원돼야 한다. DISTRO_FEATURE에서 지원하는 기능들 alsa ALSA를 지원 (지원하면 OSS 호환 Kernel module이 설치돼 있다.) api-documentation Recipe를 Build하는 동안 API 문서를 생성 bluetooth Bluetooth를 지원(통합된 Bluetooth만 해당) Bluz5 핵심 Bluetooth layer와 Protocol 지원을 제공하는 BlueZ version 5를 포함 cramsfs CramFS를 지원 directfb DirectFB를 지원 ext2 File을 저장하게 내장 Harddisk / Micro driver를 가진 Device를 지원하기 위한 도구를 포함(Flash만 지원하는 Device 대신) ipsec IPSec를 지원 Ipv6 IPv6를 지원 irda IrDA를 지원 keyboard Keyboard를 지원(e.g. Keymap이 booting하는 동안 Loading된다.) ldconfig Target에서 ldconfig와 ld.so.conf를 지원 nfs NFS client를 지원한다. (Device에서 NFS를 Mount 하기 위해) opengl 2차원, 3차원 Graphic을 Rendering하기 위해 사용되는 Cross language, Multi-platform application programming interface를 지원하는 OpenGL을 지원 pci PCI bus를 지원 pcmcia PCMCIA/CompactFlash를 지원 ppp PPP Dial up을 지원 ptest 개별 Recipe에서 지원하는 Package test를 Build smbfs SMB Network client를 지원 (Device에서 Microsoft window를 SAMBA로 Mount하기 위해) systemmd Service를 병렬로 시작하는 init을 완벽히 대체하며, Shell overhead 줄이고 다른 특징들을 갖는 초기화 관리자를 지원한다. 이 초기 관리자는 많은 배포판에서 사용한다. usbgadget USB gadget device를 지원(USB networking / serial / 저장장치를 위해) usbhost USB host를 지원(외부 keyboard, Mouse, 저장장치, Network 등을 연결할 수 있게) wayland Wayland Display server protocol과 Library를 지원 wifi Wifi를 지원 (통합된 wifi만 해당) x111 X server와 Library를 포함 MACHINE_FEATURES와 DISTRO_FEATURES 비교 DISTRO_FEATURES와 MACHINE_FEATURE 모두 최종 System에서 사용 수 있는 기능을 제공 Machine이 기능을 지원할 때 이 최종 System에 의해 지원되는 것을 시사하지는 않는다. 사용하는 배포판에서 해당 기능을 위한 근본적인 기반을 제공해야 하기 때문 Machine이 Wifi를 지원하지만, 배포판이 지원하지 않으면 OS에서 사용하는 Application은 Wifi 지원 기능이 비활성화된 상태로 Build될 것 그 결과 Wifi 없는 System이 될 것 배포판에서 Wifi가 지원되고 Machine이 지원하지 않으면 OS와 Module이 Wifi가 활성화 되어 있더라도 Wifi에 필요한 Module과 Application은 이 Machine이 Build된 Image에 설치되지 않을 것 변수의 범위 BitBake Meta-data는 수천 가지 변수가 있지만 이 변수는 자신이 정의된 곳에 영향을 미치고 해당 영역에서 이용 가능 기본적으로 변수에는 다음과 같은 두 가지 종류가 있다. 환경설정 파일에 정의된 변수는 모든 Recipe에서 전역 변수 주된 환경설정 File의 Parsing 순서는 다음과 같다. build/conf/local.conf &lt;layer&gt;/conf/machines/&lt;machine&gt;.conf &lt;layer&gt;/conf/distro/&lt;distro&gt;.conf Recipe file에 정의된 변수는 그 작업이 진행되는 동안 특정 Recipe에서만 사용할 수 있는 지역 변수" /><link rel="canonical" href="https://adas-study-group.github.io/yocto_basics//posts/custom-layer-generation/" /><meta property="og:url" content="https://adas-study-group.github.io/yocto_basics//posts/custom-layer-generation/" /><meta property="og:site_name" content="ADAS Study Group Tech Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-10-07T00:00:00+09:00" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"새로운 Layer 추가 사전에 OpenEmbedded Meta-data Index http://layers.openembedded.org 에서 이미 이용 가능한 비슷한 Layer가 있는지 확인하는 것이 좋다. 필요한 Layer를 찾을 수 없으면 다음 단계로 Directory를 생성한다. meta- 로 시작는 것을 추천한다. Layer의 환경설정 file은 모든 Layer에서 필요하고, conf/layer.conf file로 되어 있다. 이 file은 Text editor를 사용해 수작업으로 만들 수도 있지만, 다음과 같이 Poky에서 제공하는 Script로 만들 수 있다. Creating Layer 1 2 3 cd ~/poky source oe-init-build-env bitbake-layers create-layer ../poky/meta-mylayer Script로 Layer를 생성하기 위해 Layer 우선순위 값 입력하고 샘플 내용 관련된 질문에 답을 입력한다. 예시 사용자 Layer를 작업하기 위해 다른 Layer를 추가 할 필요가 있을 때, 사용하는 변수 LAYERVERSION 하나의 숫자로 Layer의 Version을 표시할 때, 사용하는 선택적 변수다. 이 변수는 LAYERDEPENDS 변수에서 Layer 특정 Version에 의존성을 걸기 위해 사용하고, LAYERVERSION_newlayer = “1” 와 같이 Layer의 이름에 접미사를 붙여 사용한다. LAYERDEPENDS 공백으로 분리 Recipe의 의존성을 걸기 위해 Layer목록을 가진다. 선택적으로 otherlayer:2 와 같이 Layer의 이름 끝에 콜론을 추가해 의존성과 같이 Layer Version을 적시 할 수도 있다. 이 변수도 특정 Layer의 이름과 함께, LAYERDEPENDS_newlayer = “otherlayer” 와 같이 Layer의 이름에 접미사를 붙여 사용한다. 의존성을 만족하지 않거나 Version 정보가 맞지 않으면 Error가 발생 Layer에서 Metadata 추가(Layer 구조의 기반을 만들고 확장하는 방법) Layer을 사용하는 목적은 bitbake database에 meta-data를 추가하거나 변경하기 위함 많이 추가하는 것은 Application, Library, 혹은 Service server와 같이 Project와 관련된 것 새로운 특징을 추가 하는 것보다 SSH서버를 위한 초기 Network 값 또는 Booting 화면의 예와 같이 사용자가 필요로 하는 기존 설정을 변경하는 것이 더 자주 이뤄 진다. 기존의 것을 바꾸기 위해 새로운 Layer, Recipe, Image, .bbappend file 들에서 Meta-data file 여러 종류를 포함할 수 있다. 앞에서 사용한 Script는 두 개의 예제 file과 새로운 Layer를 만들 때 사용됐다. 첫 번째 example_0.1.bb는 Recipe의 예제다. Example_0.1.bbappend는 example_0.1.bb를 포함하고 내용을 수정할 때 사용하는 bbappend의 예제이다. meta-yocto-bsp 또는 meta-yocto에 따른 여러 .bbappend 예제가 있고, 많이 사용하는 것들 추후 정리 (12장) Image 생성 Image file은 정해진 방식에서 목적을 가지고 설정된 Package의 집합 기존 Image에 필요한 Package를 추가하고 환경설정을 덮어씌운 새로운 Image를 만들 수 있다. 또한 처음부터 새로운 Image를 만들 수도 있다. Image를 필요에 맞게 만들고 작은 수정 했 때 그 코드를 재사용하는 것이 매우 편리 이는 코드 유지 보수를 쉽게 만들고 기능상 차이점은 강조됨 예시 core-image-sato image에서 application을 포함하기 원하고 하나의 Image 특징을 제거하기 원한다면 다음 code를 recipes-my/images/my-image-sato.bb에 추가해 image를 생성할 수 있다. require recipes-sato/image/core-image-sato.bb IMAGE_FEATURES_remove = &quot;splash&quot; CORE_IMAGE_EXTRA_INSTALL += &quot;myapp&quot; 처음부터 Image를 생성할 필요가 있을 때, 쉽고 유용하게 사용되는 Image 특징의 집합을 제공하는 core-image class를 사용해 그런 작업을 빠르게 할 수 있다. 예를 들면 recipe-my/images/my-image-nano.bb에서 Image는 다음과 같이 구성됨 inherit core-image IMAGE_FEATURES += &quot;ssh-server-openssh splash&quot; CORE_IMAGE_EXTRA_INSTALL += &quot;nano&quot; Append 연산자(+=)는 새로운 IMAGE_FEATURE 변수가 build/conf/local.conf에 추가될 수 있게 보장하기 위해 사용됨 core-image class를 상속받을 때 이미지 생성과 IMAGE_FEATURES 변수를 쉽게 추가하고 코드 중복을 피하게 CORE_IMAGE_EXTRA_INSTALL 변수를 사용해 Image에 추가 Package를 포함한다. IMAGE_INSTALL 변수는 CORE_IMAGE_EXTRA_INSTALL을 추가하고 IMAGE_FEATURES에 관련된 Package를 Root file system에 생성한다. IMAGE_FEATURES 추가가능 features allow-empty-password Dropbear와 OpenSSH에서 빈 호를 사용해 root 계정으로 로그인 할 수 있게 허용한다. dpg-pkgs Image에 설치된 모든 Package의 Debug symbol package를 설치한다. debug-tweaks 개발에 필요한 Package를 설치해 Image를 만든다. dev-pkgs Image에 설치된 모든 Package의 개발 Package (Header와 추가 Library)를 설치한다. eclipse-debug Eclipse IDE에서 원격 Debugging을 지원하게 한다. empty-root-password root 암호를 빈 문자열로 설정한다. Hwcodecs HW 가속되는 Codec을 설치한다. nfs-server NFS server를 설치한다. package-management Package 관리도구를 설치하고 Package 관리 Database를 가진다. perf perf, systemtap, LTTng 같은 Profiling 도구를 설치한다. post-install-logging Target system에서 image를 처음으로 booting할 때 post-install script 실행을 /var/log/postinstall.log file에 저장한다. ptest-pkgs ptest 가 활성화된 모든 Recipe의 ptest Package를 설치한다. read-only-rootfs Root file system이 읽기만 가능하게 Image를 만든다. splash Booting하는 동안 Splash 화면이 보이게 한다. ssh-server-dropbear Dropbear SSH server 를 설치한다. ssh-server-openssh Dropbear보다 많은 기능을 가진 OpenSSH server를 설치한다. staticdev-pkgs Image에서 설치된 모든 Package의 정적 개발 Package (즉, *.a file들을 포함한 static library)를 설치한다. tools-debug strace와 gdb 같은 debugging도구를 설치한다. tools-sdk Device에서 실행하는 전체 SDK를 설치한다. Tools-testapps Device test 도구를 설치한다. (e.g. touch screen debugging) x11 X server를 설치한다. x11-base 최소 환경을 가진 X server를 설치한다. x11-sato OpenedHand Sato 환경을 설치한다. Package Recipe 추가 Package Recipe는 BitBake가 Application, Kernel module, 또는 Project 에서 제공하는 SW를 Download, 압축풀기, Compile, 설치하는 방법을 제시한다. Poky는 Autotools, Cmake, QMake를 기반으로 하는 Project로 가장 흔한 개발 도구를 추상화한 여러 Class를 가지고 있다. Poky에 있는 Class의 목록은 http://www.yoctoproject.org/docs/2.4/ref-manual/ref-manual.html 에서 볼 수 있다. Compile과 설치 작업을 하는 간단한 Recipe 예제는 다음과 같다. do_compile과 do_install code 영역은 build와 결과 binary를 ${D}로 언급된 Target directory에 설치 하기 위한 shell script 명령어를 사용한다. Autotools기반 Project의 경우, 다음과 같이 poky/meta/recipecore/dbus-wait/dbus-wait_git.bb의 일부 축약된 Recipe를 보면 알 수 있듯이 autotools Class를 사용해 많은 Code 중복을 피할 수 있다. DESCRIPTION = &quot;A simple tool to wait for a specific signal over DBus&quot; ... inherit autotools Class를 상속받는 단순 행위는 다음 작업을 하기 위해 요구되는 모든 Code를 제공한다. Configure script code와 결과물 update libtool script update Configure script 실행 make 실행 make install 실행 이와 같은 개념은 CMake와 QMake의 경우와 같이 다른 Build 도구에도 적용됨 지원되는 Class의 수는 계속 늘어나고 매 release시에 포함된다. recipetool을 사용해 기본 Package Recipe 자동 생성 recipetool 을 사용하면 Source code file을 기반으로 기본 Recipe를 쉽게 만들 수 있다. 압축을 풀고 Source file을 지정할 수 있으면 recipetool은 Recip를 만들고 신규 Recipe file에 모든 file에 모든 build 정보를 자동으로 설정 autotools로 build하는 Application recipetools을 사용해 기본 Recipe를 생성하면 Build 의존성을 가진 Recipe를 생성한다. 이 Recipe는 autotools Class를 상속하고 License 요구사항과 Checksum을 설정한다. recipetool은 내용의 이해를 돕기 위해 주석을 함께 포함한 Recipe를 생성한다. 모든 주석은 Meta-layer에 Recipe file을 통합할 때 삭제할 수 있다. https://github.com/OSSystems/bbexample 에 있는 bbexample을 사용해 Recipe를 생성 1 2 source oe-init-build-env build recipetool create -V 1.0 https://github.com/OSSystems/bbexample recipetool은 URL에서 Source code를 Download해 내용을 분석하고 bbexample_git.bb file을 생성한다. Source code 기반으로 아래 Recipe file을 생성한다. recipetool이 기본 Recipe를 생성하더라도 최종 사용할 Recipe로 완벽하지 않다. Compile option, 추가 Meta-data 정보 등을 확인해야 한다. bbexample_git.bb file은 recipetool을 실행한 Directory에 생성되기 때문에 meta-newlayer/recipe-mine/bbexample/bbexample_git.bb처럼 필요한 위치에 file을 복사해서 사용해야 한다. 복사하고 나면 bitbake를 사용해 build할 수 있다. 신규 Machine 추가 Poky에서 사용하기 위해 새로운 Machine을 만드는 것은 간단하다. 본질적으로 작업을 위한 Machine에 필요한 정보를 제공한다. Boot loader, kernel, HW 지원 Driver는 BSP layer에서 Board에 통합하기 위해 시작 전에 점검한다. Yocto Project는 현재 사용하는 Embedded Architecture의 대부분을 지원 Machine 정의에서 사용되는 변수 TARGET_ARCH ARM과 i586과 같은 Machine Architecture를 설정 PREFERRED_PROVIDER_virtual/kernel 특정한 Kernel을 사용하는 경우 기본 Kernel (linux-yocto) 덮어쓴다. SERIAL_CONSOLES Serial console과 속도를 정의 MACHINE_FEATURES 필요한 SW stack이 기본 Image에 포함되게 HW특성을 정의 KERNEL_IMAGETYPE zImage나 uImage 같은 Kernel image 종류를 선택하기 위해 사용 IMAGE_FSTYPES tar.gz, ext4, ubifs 같은 일반적인 File system image 종류를 선택 meta-yocto-bsp/conf/machine의 Poky source code에서 Machine file들의 예제를 볼 수 있다. 새로운 Machine을 만들 때, 특히 MACHINE_FEATURES 에서 지원하는 기술을 잘 살펴 봐야 한다. 이런 방법으로 특성을 지원하기 위해 필요한 SW가 Image에 설치된다. MACHINE_FEATURES에 대해 이용 가능한 값 acpi HW가 ACPI(x86/x86_64에 대해서만)를 구비 alsa HW가 ALSA Audio Driver를 구비 apm HW가 APM(또는 APM emulation)을 사용 bluetooth HW가 통합된 Bluetooth를 구비 efi EFI로 Booting 할 수 있게 지원 ext2 HW가 HDD 또는 Micro drive를 구비 IRDA HW가 IrDA를 지원 keyboard HW가 Keyboard를 구비 pcbios BIOS로 Booting할 수 있게 지원 pci HW가 PCI bus를 구비 pcmcia HW가 PCMCIA 또는 CompactFlash Socket을 구비 phone Mobile phone(음성)을 지원 qvga QVGA(320x240) Display를 지원 rtc Real time clock을 지원 screen HW가 화면을 구비 serial HW가 Serial(일반적으로 RS232)을 지원 touchscreen HW가 Touch screen을 구비 usbgadget HW가 USB gadget driver와 호환 usbhost HW가 USB host와 호환 vflat FAT file system을 지원 wifi HW가 통합된 wifi를 구비 Machine에 Image 배치 BSP Layer 개발이 끝날 때 까지 자주 잊는 것 중 하나는 Machine에 바로 사용할 수 있는 Image를 생성하는 것 사용하는 Image의 종류는 Processor, Board 에 있는 주변장치, Project 제약 등과 같이 여러 경우에 따라 달라진다. 저장소에 직접 사용하기 위해 가장 많이 사용하는 Image 종류는 Partition된 Image Yocto Project는 이런 Image를 생성할 때 유연하게 사용할 수 있는 wic도구가 있다. Target image layer을 정의하는데 많이 사용하는 언어로 작성된 Template file(wks)을 기반으로 Partition된 Image를 생성할 수 있다. 이것은 http://www.yoctoproject.org/docs/2.4/ref-manual/ref-manual.html#openebedded-kickstart-wks-reference 를 참고해 작성 wks file은 Meta-data의 wic directory에 있다. 다른 Image layout을 지정할 수 있도록 Directory에 여러 개의 file 갖고 있는 것이 일반적이다. Machine과 일치하는 Layout을 선택하는 것이 중요 예시 두 개의 Partition으로 SD card에 SPL과 U-Boot를 사용하는 i.MX 기반 Machine을 고려할 때 하나는 Boot file용이고 다른 하나는 Root file system용이다. 각 wks file은 다음과 같다. wic 기반 Image를 생성 할 수 있게 하려면 IMAGE_FSTYPES에 추가해야 한다. WKS_FILE 변수에 wks file을 설정해 사용할 수 있다. Custom 배포 배포의 생성은 단순함과 복잡함이 섞여 있다. 배포 file을 만드는 절차는 매우 쉽다. 배포 환경설정은 Poky가 사용하는 방식에 큰 영향을 주고, 사용한 Option에 따라 이전에 Build된 Binary에 호환성을 갖지 않는 데 영향을 줄 수 있다. 배포는 Tool chain version, Graphic Backend, OpenGL 지원 등과 같은 전역 Option을 정의한다. Poky에서 제공하는 기본 설정을 사용하면 간단한 배포를 만들 수 있지만, 사용자의 요구 사항을 모두 만족시킬 수는 없다. 일반적으로 Poky의 작은 Option 집합을 의도적으로 변화 시킨다. E.g. Framebuffer를 사용하게 X11 지원을 제거 Poky 배포의 재사용과 필요한 변수를 덮어 쓰는 것을 쉽게 수행할 수 있다. E.g. Sample 배포는 다음 &lt;layer&gt;/conf/distro/mydistro.conf file처럼 표현한다. 생성된 배포를 사용하기 위해 build/conf/local.conf에 다음 code 한 부분만 추가하면 된다. DISTRO = “mydistro” DISTRO_FEATURES 변수는 Recipe를 설정하고 Package를 Image에 설치하는 방법에 영향을 미친다. E.g. 어떤 Machine과 Image에서 Sound를 사용하기 원하면 alsa 기능이 지원돼야 한다. DISTRO_FEATURE에서 지원하는 기능들 alsa ALSA를 지원 (지원하면 OSS 호환 Kernel module이 설치돼 있다.) api-documentation Recipe를 Build하는 동안 API 문서를 생성 bluetooth Bluetooth를 지원(통합된 Bluetooth만 해당) Bluz5 핵심 Bluetooth layer와 Protocol 지원을 제공하는 BlueZ version 5를 포함 cramsfs CramFS를 지원 directfb DirectFB를 지원 ext2 File을 저장하게 내장 Harddisk / Micro driver를 가진 Device를 지원하기 위한 도구를 포함(Flash만 지원하는 Device 대신) ipsec IPSec를 지원 Ipv6 IPv6를 지원 irda IrDA를 지원 keyboard Keyboard를 지원(e.g. Keymap이 booting하는 동안 Loading된다.) ldconfig Target에서 ldconfig와 ld.so.conf를 지원 nfs NFS client를 지원한다. (Device에서 NFS를 Mount 하기 위해) opengl 2차원, 3차원 Graphic을 Rendering하기 위해 사용되는 Cross language, Multi-platform application programming interface를 지원하는 OpenGL을 지원 pci PCI bus를 지원 pcmcia PCMCIA/CompactFlash를 지원 ppp PPP Dial up을 지원 ptest 개별 Recipe에서 지원하는 Package test를 Build smbfs SMB Network client를 지원 (Device에서 Microsoft window를 SAMBA로 Mount하기 위해) systemmd Service를 병렬로 시작하는 init을 완벽히 대체하며, Shell overhead 줄이고 다른 특징들을 갖는 초기화 관리자를 지원한다. 이 초기 관리자는 많은 배포판에서 사용한다. usbgadget USB gadget device를 지원(USB networking / serial / 저장장치를 위해) usbhost USB host를 지원(외부 keyboard, Mouse, 저장장치, Network 등을 연결할 수 있게) wayland Wayland Display server protocol과 Library를 지원 wifi Wifi를 지원 (통합된 wifi만 해당) x111 X server와 Library를 포함 MACHINE_FEATURES와 DISTRO_FEATURES 비교 DISTRO_FEATURES와 MACHINE_FEATURE 모두 최종 System에서 사용 수 있는 기능을 제공 Machine이 기능을 지원할 때 이 최종 System에 의해 지원되는 것을 시사하지는 않는다. 사용하는 배포판에서 해당 기능을 위한 근본적인 기반을 제공해야 하기 때문 Machine이 Wifi를 지원하지만, 배포판이 지원하지 않으면 OS에서 사용하는 Application은 Wifi 지원 기능이 비활성화된 상태로 Build될 것 그 결과 Wifi 없는 System이 될 것 배포판에서 Wifi가 지원되고 Machine이 지원하지 않으면 OS와 Module이 Wifi가 활성화 되어 있더라도 Wifi에 필요한 Module과 Application은 이 Machine이 Build된 Image에 설치되지 않을 것 변수의 범위 BitBake Meta-data는 수천 가지 변수가 있지만 이 변수는 자신이 정의된 곳에 영향을 미치고 해당 영역에서 이용 가능 기본적으로 변수에는 다음과 같은 두 가지 종류가 있다. 환경설정 파일에 정의된 변수는 모든 Recipe에서 전역 변수 주된 환경설정 File의 Parsing 순서는 다음과 같다. build/conf/local.conf &lt;layer&gt;/conf/machines/&lt;machine&gt;.conf &lt;layer&gt;/conf/distro/&lt;distro&gt;.conf Recipe file에 정의된 변수는 그 작업이 진행되는 동안 특정 Recipe에서만 사용할 수 있는 지역 변수","@type":"BlogPosting","headline":"사용자 Layer 생성","dateModified":"2020-10-07T00:00:00+09:00","datePublished":"2020-10-07T00:00:00+09:00","url":"https://adas-study-group.github.io/yocto_basics//posts/custom-layer-generation/","mainEntityOfPage":{"@type":"WebPage","@id":"https://adas-study-group.github.io/yocto_basics//posts/custom-layer-generation/"},"author":{"@type":"Person","name":"Jo, SeungHyeon"},"@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/about/us.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">ADAS Study Group Tech Blog</a></div><div class="site-subtitle font-italic">No Pain No Gain</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <a href="https://github.com/jayleekr" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['',''].join('@'))" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" > <i class="fas fa-rss"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>사용자 Layer 생성</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>사용자 Layer 생성</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 7, 2020, 12:00 AM +0900" > Oct 7, 2020 <i class="unloaded">2020-10-07T00:00:00+09:00</i> </span> by <span class="author"> Jo, SeungHyeon </span></div><div> Updated <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Oct 20, 2020, 4:24 PM +0900" > Oct 20, 2020 <i class="unloaded">2020-10-20T16:24:03+09:00</i> </span></div></div><div class="post-content"><h2 id="새로운-layer-추가">새로운 Layer 추가</h2><ol><li>사전에 OpenEmbedded Meta-data Index <a href="http://layers.openembedded.org">http://layers.openembedded.org</a> 에서 이미 이용 가능한 비슷한 Layer가 있는지 확인하는 것이 좋다.</li><li>필요한 Layer를 찾을 수 없으면 다음 단계로 Directory를 생성한다. meta- 로 시작는 것을 추천한다.</li><li><p>Layer의 환경설정 file은 모든 Layer에서 필요하고, conf/layer.conf file로 되어 있다. 이 file은 Text editor를 사용해 수작업으로 만들 수도 있지만, 다음과 같이 Poky에서 제공하는 Script로 만들 수 있다.</p><ul><li>Creating Layer</li></ul><div class="language-terminal highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="go">cd ~/poky
source oe-init-build-env
 bitbake-layers create-layer ../poky/meta-mylayer
</span></pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/post/2020-10-07/01_create-layer.png" alt="COUT: create-layer" /></p><ul><li>Script로 Layer를 생성하기 위해 Layer 우선순위 값 입력하고 샘플 내용 관련된 질문에 답을 입력한다.</li><li>예시 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/post/2020-10-07/02_meta-mylayer.png" alt="meta-mylayer" /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/post/2020-10-07/03_meta-newlayer.png" alt="meta-mylayer" /></li></ul></li><li>사용자 Layer를 작업하기 위해 다른 Layer를 추가 할 필요가 있을 때, 사용하는 변수<ul><li>LAYERVERSION<ul><li>하나의 숫자로 Layer의 Version을 표시할 때, 사용하는 선택적 변수다.</li><li>이 변수는 LAYERDEPENDS 변수에서 Layer 특정 Version에 의존성을 걸기 위해 사용하고, LAYERVERSION_newlayer = “1” 와 같이 Layer의 이름에 접미사를 붙여 사용한다.</li></ul></li><li>LAYERDEPENDS<ul><li>공백으로 분리</li><li>Recipe의 의존성을 걸기 위해 Layer목록을 가진다.</li><li>선택적으로 otherlayer:2 와 같이 Layer의 이름 끝에 콜론을 추가해 의존성과 같이 Layer Version을 적시 할 수도 있다.</li><li>이 변수도 특정 Layer의 이름과 함께, LAYERDEPENDS_newlayer = “otherlayer” 와 같이 Layer의 이름에 접미사를 붙여 사용한다.</li></ul></li><li>의존성을 만족하지 않거나 Version 정보가 맞지 않으면 Error가 발생</li></ul></li></ol><h2 id="layer에서-metadata-추가layer-구조의-기반을-만들고-확장하는-방법">Layer에서 Metadata 추가(Layer 구조의 기반을 만들고 확장하는 방법)</h2><ul><li>Layer을 사용하는 목적은 bitbake database에 meta-data를 추가하거나 변경하기 위함</li><li>많이 추가하는 것은 Application, Library, 혹은 Service server와 같이 Project와 관련된 것<ul><li>새로운 특징을 추가 하는 것보다 SSH서버를 위한 초기 Network 값 또는 Booting 화면의 예와 같이 사용자가 필요로 하는 기존 설정을 변경하는 것이 더 자주 이뤄 진다.</li></ul></li><li>기존의 것을 바꾸기 위해 새로운 Layer, Recipe, Image, .bbappend file 들에서 Meta-data file 여러 종류를 포함할 수 있다.<ul><li>앞에서 사용한 Script는 두 개의 예제 file과 새로운 Layer를 만들 때 사용됐다. 첫 번째 example_0.1.bb는 Recipe의 예제다. Example_0.1.bbappend는 example_0.1.bb를 포함하고 내용을 수정할 때 사용하는 bbappend의 예제이다.</li></ul></li><li>meta-yocto-bsp 또는 meta-yocto에 따른 여러 .bbappend 예제가 있고, 많이 사용하는 것들 추후 정리 (12장)</li></ul><h2 id="image-생성">Image 생성</h2><ul><li>Image file은 정해진 방식에서 목적을 가지고 설정된 Package의 집합</li><li>기존 Image에 필요한 Package를 추가하고 환경설정을 덮어씌운 새로운 Image를 만들 수 있다. 또한 처음부터 새로운 Image를 만들 수도 있다.<ul><li>Image를 필요에 맞게 만들고 작은 수정 했 때 그 코드를 재사용하는 것이 매우 편리</li><li>이는 코드 유지 보수를 쉽게 만들고 기능상 차이점은 강조됨</li><li>예시<ul><li><p>core-image-sato image에서 application을 포함하기 원하고 하나의 Image 특징을 제거하기 원한다면 다음 code를 recipes-my/images/my-image-sato.bb에 추가해 image를 생성할 수 있다.</p><pre><code class="language-recipe">require recipes-sato/image/core-image-sato.bb
IMAGE_FEATURES_remove = "splash"
CORE_IMAGE_EXTRA_INSTALL += "myapp"
</code></pre></li></ul></li><li><p>처음부터 Image를 생성할 필요가 있을 때, 쉽고 유용하게 사용되는 Image 특징의 집합을 제공하는 core-image class를 사용해 그런 작업을 빠르게 할 수 있다. 예를 들면 recipe-my/images/my-image-nano.bb에서 Image는 다음과 같이 구성됨</p><pre><code class="language-recipe">inherit core-image
IMAGE_FEATURES += "ssh-server-openssh splash"
CORE_IMAGE_EXTRA_INSTALL += "nano"
</code></pre></li><li>Append 연산자(+=)는 새로운 IMAGE_FEATURE 변수가 build/conf/local.conf에 추가될 수 있게 보장하기 위해 사용됨</li><li>core-image class를 상속받을 때 이미지 생성과 IMAGE_FEATURES 변수를 쉽게 추가하고 코드 중복을 피하게 CORE_IMAGE_EXTRA_INSTALL 변수를 사용해 Image에 추가 Package를 포함한다.</li><li>IMAGE_INSTALL 변수는 CORE_IMAGE_EXTRA_INSTALL을 추가하고 IMAGE_FEATURES에 관련된 Package를 Root file system에 생성한다.</li><li><p>IMAGE_FEATURES 추가가능 features</p><div class="table-wrapper"><table><tbody><tr><td>allow-empty-password<td>Dropbear와 OpenSSH에서 빈 호를 사용해 root 계정으로 로그인 할 수 있게 허용한다.<tr><td>dpg-pkgs<td>Image에 설치된 모든 Package의 Debug symbol package를 설치한다.<tr><td>debug-tweaks<td>개발에 필요한 Package를 설치해 Image를 만든다.<tr><td>dev-pkgs<td>Image에 설치된 모든 Package의 개발 Package (Header와 추가 Library)를 설치한다.<tr><td>eclipse-debug<td>Eclipse IDE에서 원격 Debugging을 지원하게 한다.<tr><td>empty-root-password<td>root 암호를 빈 문자열로 설정한다.<tr><td>Hwcodecs<td>HW 가속되는 Codec을 설치한다.<tr><td>nfs-server<td>NFS server를 설치한다.<tr><td>package-management<td>Package 관리도구를 설치하고 Package 관리 Database를 가진다.<tr><td>perf<td>perf, systemtap, LTTng 같은 Profiling 도구를 설치한다.<tr><td>post-install-logging<td>Target system에서 image를 처음으로 booting할 때 post-install script 실행을 /var/log/postinstall.log file에 저장한다.<tr><td>ptest-pkgs<td>ptest 가 활성화된 모든 Recipe의 ptest Package를 설치한다.<tr><td>read-only-rootfs<td>Root file system이 읽기만 가능하게 Image를 만든다.<tr><td>splash<td>Booting하는 동안 Splash 화면이 보이게 한다.<tr><td>ssh-server-dropbear<td>Dropbear SSH server 를 설치한다.<tr><td>ssh-server-openssh<td>Dropbear보다 많은 기능을 가진 OpenSSH server를 설치한다.<tr><td>staticdev-pkgs<td>Image에서 설치된 모든 Package의 정적 개발 Package (즉, *.a file들을 포함한 static library)를 설치한다.<tr><td>tools-debug<td>strace와 gdb 같은 debugging도구를 설치한다.<tr><td>tools-sdk<td>Device에서 실행하는 전체 SDK를 설치한다.<tr><td>Tools-testapps<td>Device test 도구를 설치한다. (e.g. touch screen debugging)<tr><td>x11<td>X server를 설치한다.<tr><td>x11-base<td>최소 환경을 가진 X server를 설치한다.<tr><td>x11-sato<td>OpenedHand Sato 환경을 설치한다.</table></div></li></ul></li></ul><h2 id="package-recipe-추가">Package Recipe 추가</h2><ul><li>Package Recipe는 BitBake가 Application, Kernel module, 또는 Project 에서 제공하는 SW를 Download, 압축풀기, Compile, 설치하는 방법을 제시한다.</li><li>Poky는 Autotools, Cmake, QMake를 기반으로 하는 Project로 가장 흔한 개발 도구를 추상화한 여러 Class를 가지고 있다.<ul><li>Poky에 있는 Class의 목록은 <a href="http://www.yoctoproject.org/docs/2.4/ref-manual/ref-manual.html">http://www.yoctoproject.org/docs/2.4/ref-manual/ref-manual.html</a> 에서 볼 수 있다.</li></ul></li><li>Compile과 설치 작업을 하는 간단한 Recipe 예제는 다음과 같다. <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/post/2020-10-07/04_recipe-example.png" alt="recipe-example" /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/post/2020-10-07/05_recipe-example-from-book.png" alt="recipe-example-from-book" /><ul><li>do_compile과 do_install code 영역은 build와 결과 binary를 ${D}로 언급된 Target directory에 설치 하기 위한 shell script 명령어를 사용한다.</li><li><p>Autotools기반 Project의 경우, 다음과 같이 poky/meta/recipecore/dbus-wait/dbus-wait_git.bb의 일부 축약된 Recipe를 보면 알 수 있듯이 autotools Class를 사용해 많은 Code 중복을 피할 수 있다.</p><pre><code class="language-recipe">DESCRIPTION = "A simple tool to wait for a specific signal over DBus"
...
inherit autotools
</code></pre></li><li>Class를 상속받는 단순 행위는 다음 작업을 하기 위해 요구되는 모든 Code를 제공한다.<ul><li>Configure script code와 결과물 update</li><li>libtool script update</li><li>Configure script 실행</li><li>make 실행</li><li>make install 실행</li></ul></li><li>이와 같은 개념은 CMake와 QMake의 경우와 같이 다른 Build 도구에도 적용됨</li><li>지원되는 Class의 수는 계속 늘어나고 매 release시에 포함된다.</li></ul></li></ul><h3 id="recipetool을-사용해-기본-package-recipe-자동-생성">recipetool을 사용해 기본 Package Recipe 자동 생성</h3><ul><li>recipetool 을 사용하면 Source code file을 기반으로 기본 Recipe를 쉽게 만들 수 있다.</li><li>압축을 풀고 Source file을 지정할 수 있으면 recipetool은 Recip를 만들고 신규 Recipe file에 모든 file에 모든 build 정보를 자동으로 설정</li><li>autotools로 build하는 Application<ul><li>recipetools을 사용해 기본 Recipe를 생성하면 Build 의존성을 가진 Recipe를 생성한다.</li><li>이 Recipe는 autotools Class를 상속하고 License 요구사항과 Checksum을 설정한다.</li><li>recipetool은 내용의 이해를 돕기 위해 주석을 함께 포함한 Recipe를 생성한다.<ul><li>모든 주석은 Meta-layer에 Recipe file을 통합할 때 삭제할 수 있다.</li></ul></li><li><p><a href="https://github.com/OSSystems/bbexample">https://github.com/OSSystems/bbexample</a> 에 있는 bbexample을 사용해 Recipe를 생성</p><div class="language-terminal highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="go">source oe-init-build-env build
recipetool create -V 1.0 https://github.com/OSSystems/bbexample
</span></pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/post/2020-10-07/06_recipetool-create.png" alt="COUT: recipetool-create" /></p><ul><li>recipetool은 URL에서 Source code를 Download해 내용을 분석하고 bbexample_git.bb file을 생성한다.</li><li>Source code 기반으로 아래 Recipe file을 생성한다. <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/post/2020-10-07/07_bbexample_git_bb.png" alt="bbexample_git_bb" /><ul><li>recipetool이 기본 Recipe를 생성하더라도 최종 사용할 Recipe로 완벽하지 않다. Compile option, 추가 Meta-data 정보 등을 확인해야 한다.</li><li>bbexample_git.bb file은 recipetool을 실행한 Directory에 생성되기 때문에 meta-newlayer/recipe-mine/bbexample/bbexample_git.bb처럼 필요한 위치에 file을 복사해서 사용해야 한다.</li><li>복사하고 나면 bitbake를 사용해 build할 수 있다.</li></ul></li></ul></li></ul></li></ul><h2 id="신규-machine-추가">신규 Machine 추가</h2><ul><li>Poky에서 사용하기 위해 새로운 Machine을 만드는 것은 간단하다.<ul><li>본질적으로 작업을 위한 Machine에 필요한 정보를 제공한다.</li></ul></li><li>Boot loader, kernel, HW 지원 Driver는 BSP layer에서 Board에 통합하기 위해 시작 전에 점검한다.</li><li>Yocto Project는 현재 사용하는 Embedded Architecture의 대부분을 지원</li><li><p>Machine 정의에서 사용되는 변수</p><div class="table-wrapper"><table><tbody><tr><td>TARGET_ARCH<td>ARM과 i586과 같은 Machine Architecture를 설정<tr><td>PREFERRED_PROVIDER_virtual/kernel<td>특정한 Kernel을 사용하는 경우 기본 Kernel (linux-yocto) 덮어쓴다.<tr><td>SERIAL_CONSOLES<td>Serial console과 속도를 정의<tr><td>MACHINE_FEATURES<td>필요한 SW stack이 기본 Image에 포함되게 HW특성을 정의<tr><td>KERNEL_IMAGETYPE<td>zImage나 uImage 같은 Kernel image 종류를 선택하기 위해 사용<tr><td>IMAGE_FSTYPES<td>tar.gz, ext4, ubifs 같은 일반적인 File system image 종류를 선택</table></div></li><li>meta-yocto-bsp/conf/machine의 Poky source code에서 Machine file들의 예제를 볼 수 있다.</li><li>새로운 Machine을 만들 때, 특히 MACHINE_FEATURES 에서 지원하는 기술을 잘 살펴 봐야 한다.<ul><li>이런 방법으로 특성을 지원하기 위해 필요한 SW가 Image에 설치된다.</li><li><p>MACHINE_FEATURES에 대해 이용 가능한 값</p><div class="table-wrapper"><table><tbody><tr><td>acpi<td>HW가 ACPI(x86/x86_64에 대해서만)를 구비<tr><td>alsa<td>HW가 ALSA Audio Driver를 구비<tr><td>apm<td>HW가 APM(또는 APM emulation)을 사용<tr><td>bluetooth<td>HW가 통합된 Bluetooth를 구비<tr><td>efi<td>EFI로 Booting 할 수 있게 지원<tr><td>ext2<td>HW가 HDD 또는 Micro drive를 구비<tr><td>IRDA<td>HW가 IrDA를 지원<tr><td>keyboard<td>HW가 Keyboard를 구비<tr><td>pcbios<td>BIOS로 Booting할 수 있게 지원<tr><td>pci<td>HW가 PCI bus를 구비<tr><td>pcmcia<td>HW가 PCMCIA 또는 CompactFlash Socket을 구비<tr><td>phone<td>Mobile phone(음성)을 지원<tr><td>qvga<td>QVGA(320x240) Display를 지원<tr><td>rtc<td>Real time clock을 지원<tr><td>screen<td>HW가 화면을 구비<tr><td>serial<td>HW가 Serial(일반적으로 RS232)을 지원<tr><td>touchscreen<td>HW가 Touch screen을 구비<tr><td>usbgadget<td>HW가 USB gadget driver와 호환<tr><td>usbhost<td>HW가 USB host와 호환<tr><td>vflat<td>FAT file system을 지원<tr><td>wifi<td>HW가 통합된 wifi를 구비</table></div></li></ul></li><li>Machine에 Image 배치<ul><li>BSP Layer 개발이 끝날 때 까지 자주 잊는 것 중 하나는 Machine에 바로 사용할 수 있는 Image를 생성하는 것</li><li>사용하는 Image의 종류는 Processor, Board 에 있는 주변장치, Project 제약 등과 같이 여러 경우에 따라 달라진다.<ul><li>저장소에 직접 사용하기 위해 가장 많이 사용하는 Image 종류는 Partition된 Image</li></ul></li><li>Yocto Project는 이런 Image를 생성할 때 유연하게 사용할 수 있는 wic도구가 있다.<ul><li>Target image layer을 정의하는데 많이 사용하는 언어로 작성된 Template file(wks)을 기반으로 Partition된 Image를 생성할 수 있다.</li><li>이것은 <a href="http://www.yoctoproject.org/docs/2.4/ref-manual/ref-manual.html#openebedded-kickstart-wks-reference">http://www.yoctoproject.org/docs/2.4/ref-manual/ref-manual.html#openebedded-kickstart-wks-reference</a> 를 참고해 작성</li><li>wks file은 Meta-data의 wic directory에 있다.<ul><li>다른 Image layout을 지정할 수 있도록 Directory에 여러 개의 file 갖고 있는 것이 일반적이다.</li><li>Machine과 일치하는 Layout을 선택하는 것이 중요</li><li>예시<ul><li>두 개의 Partition으로 SD card에 SPL과 U-Boot를 사용하는 i.MX 기반 Machine을 고려할 때 하나는 Boot file용이고 다른 하나는 Root file system용이다.</li></ul></li><li>각 wks file은 다음과 같다. <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/post/2020-10-07/08_wks_file.png" alt="wks_file" /></li><li>wic 기반 Image를 생성 할 수 있게 하려면 IMAGE_FSTYPES에 추가해야 한다.</li><li>WKS_FILE 변수에 wks file을 설정해 사용할 수 있다.</li></ul></li></ul></li></ul></li></ul><h2 id="custom-배포">Custom 배포</h2><ul><li>배포의 생성은 단순함과 복잡함이 섞여 있다. 배포 file을 만드는 절차는 매우 쉽다.</li><li>배포 환경설정은 Poky가 사용하는 방식에 큰 영향을 주고, 사용한 Option에 따라 이전에 Build된 Binary에 호환성을 갖지 않는 데 영향을 줄 수 있다.</li><li>배포는 Tool chain version, Graphic Backend, OpenGL 지원 등과 같은 전역 Option을 정의한다.<ul><li>Poky에서 제공하는 기본 설정을 사용하면 간단한 배포를 만들 수 있지만, 사용자의 요구 사항을 모두 만족시킬 수는 없다.</li></ul></li><li>일반적으로 Poky의 작은 Option 집합을 의도적으로 변화 시킨다.<ul><li>E.g. Framebuffer를 사용하게 X11 지원을 제거</li></ul></li><li>Poky 배포의 재사용과 필요한 변수를 덮어 쓰는 것을 쉽게 수행할 수 있다.<ul><li>E.g. Sample 배포는 다음 &lt;layer&gt;/conf/distro/mydistro.conf file처럼 표현한다. <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/post/2020-10-07/09_mydistro_conf.png" alt="mydistro_conf" /></li></ul></li><li>생성된 배포를 사용하기 위해 build/conf/local.conf에 다음 code 한 부분만 추가하면 된다.<ul><li>DISTRO = “mydistro”</li></ul></li><li>DISTRO_FEATURES 변수는 Recipe를 설정하고 Package를 Image에 설치하는 방법에 영향을 미친다.<ul><li>E.g. 어떤 Machine과 Image에서 Sound를 사용하기 원하면 alsa 기능이 지원돼야 한다.</li><li><p>DISTRO_FEATURE에서 지원하는 기능들</p><div class="table-wrapper"><table><tbody><tr><td>alsa<td>ALSA를 지원 (지원하면 OSS 호환 Kernel module이 설치돼 있다.)<tr><td>api-documentation<td>Recipe를 Build하는 동안 API 문서를 생성<tr><td>bluetooth<td>Bluetooth를 지원(통합된 Bluetooth만 해당)<tr><td>Bluz5<td>핵심 Bluetooth layer와 Protocol 지원을 제공하는 BlueZ version 5를 포함<tr><td>cramsfs<td>CramFS를 지원<tr><td>directfb<td>DirectFB를 지원<tr><td>ext2<td>File을 저장하게 내장 Harddisk / Micro driver를 가진 Device를 지원하기 위한 도구를 포함(Flash만 지원하는 Device 대신)<tr><td>ipsec<td>IPSec를 지원<tr><td>Ipv6<td>IPv6를 지원<tr><td>irda<td>IrDA를 지원<tr><td>keyboard<td>Keyboard를 지원(e.g. Keymap이 booting하는 동안 Loading된다.)<tr><td>ldconfig<td>Target에서 ldconfig와 ld.so.conf를 지원<tr><td>nfs<td>NFS client를 지원한다. (Device에서 NFS를 Mount 하기 위해)<tr><td>opengl<td>2차원, 3차원 Graphic을 Rendering하기 위해 사용되는 Cross language, Multi-platform application programming interface를 지원하는 OpenGL을 지원<tr><td>pci<td>PCI bus를 지원<tr><td>pcmcia<td>PCMCIA/CompactFlash를 지원<tr><td>ppp<td>PPP Dial up을 지원<tr><td>ptest<td>개별 Recipe에서 지원하는 Package test를 Build<tr><td>smbfs<td>SMB Network client를 지원 (Device에서 Microsoft window를 SAMBA로 Mount하기 위해)<tr><td>systemmd<td>Service를 병렬로 시작하는 init을 완벽히 대체하며, Shell overhead 줄이고 다른 특징들을 갖는 초기화 관리자를 지원한다. 이 초기 관리자는 많은 배포판에서 사용한다.<tr><td>usbgadget<td>USB gadget device를 지원(USB networking / serial / 저장장치를 위해)<tr><td>usbhost<td>USB host를 지원(외부 keyboard, Mouse, 저장장치, Network 등을 연결할 수 있게)<tr><td>wayland<td>Wayland Display server protocol과 Library를 지원<tr><td>wifi<td>Wifi를 지원 (통합된 wifi만 해당)<tr><td>x111<td>X server와 Library를 포함</table></div></li></ul></li></ul><h2 id="machine_features와-distro_features-비교">MACHINE_FEATURES와 DISTRO_FEATURES 비교</h2><ul><li>DISTRO_FEATURES와 MACHINE_FEATURE 모두 최종 System에서 사용 수 있는 기능을 제공</li><li>Machine이 기능을 지원할 때 이 최종 System에 의해 지원되는 것을 시사하지는 않는다.</li><li>사용하는 배포판에서 해당 기능을 위한 근본적인 기반을 제공해야 하기 때문</li><li>Machine이 Wifi를 지원하지만, 배포판이 지원하지 않으면 OS에서 사용하는 Application은 Wifi 지원 기능이 비활성화된 상태로 Build될 것<ul><li>그 결과 Wifi 없는 System이 될 것</li></ul></li><li>배포판에서 Wifi가 지원되고 Machine이 지원하지 않으면 OS와 Module이 Wifi가 활성화 되어 있더라도 Wifi에 필요한 Module과 Application은 이 Machine이 Build된 Image에 설치되지 않을 것</li></ul><h2 id="변수의-범위">변수의 범위</h2><ul><li>BitBake Meta-data는 수천 가지 변수가 있지만 이 변수는 자신이 정의된 곳에 영향을 미치고 해당 영역에서 이용 가능</li><li>기본적으로 변수에는 다음과 같은 두 가지 종류가 있다.<ul><li>환경설정 파일에 정의된 변수는 모든 Recipe에서 전역 변수<ul><li>주된 환경설정 File의 Parsing 순서는 다음과 같다.<ul><li>build/conf/local.conf</li><li>&lt;layer&gt;/conf/machines/&lt;machine&gt;.conf</li><li>&lt;layer&gt;/conf/distro/&lt;distro&gt;.conf</li></ul></li></ul></li><li>Recipe file에 정의된 변수는 그 작업이 진행되는 동안 특정 Recipe에서만 사용할 수 있는 지역 변수</li></ul></li></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a>, <a href='/categories/studysummary/'>StudySummary</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/yocto/" class="post-tag no-text-decoration" >Yocto</a> <a href="/tags/layer/" class="post-tag no-text-decoration" >Layer</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=사용자 Layer 생성 - ADAS Study Group Tech Blog&url=https://adas-study-group.github.io/yocto_basics//posts/custom-layer-generation/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=사용자 Layer 생성 - ADAS Study Group Tech Blog&u=https://adas-study-group.github.io/yocto_basics//posts/custom-layer-generation/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=사용자 Layer 생성 - ADAS Study Group Tech Blog&url=https://adas-study-group.github.io/yocto_basics//posts/custom-layer-generation/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory-management/">Linux Memory Management</a></li><li><a href="/posts/memory-node-zone-pageframe/">Memory Management(node,zone,pageframe)</a></li><li><a href="/posts/memory-buddy-slab/">Memory Management(buddy,slab)</a></li><li><a href="/posts/08YoctoProjectDev/">Study summary 기록 2020-09-28</a></li><li><a href="/posts/07BitbakeMetadata/">Study summary 기록 2020-09-15</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/writing/">Writing</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/yocto/">Yocto</a> <a class="post-tag" href="/tags/blogging/">Blogging</a> <a class="post-tag" href="/tags/memory/">memory</a> <a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/programminglanguage/">ProgrammingLanguage</a> <a class="post-tag" href="/tags/meetup/">meetup</a> <a class="post-tag" href="/tags/gcp/">gcp</a> <a class="post-tag" href="/tags/wsl2gui/">WSL2GUI</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/external-layer/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Oct 6, 2020 <i class="unloaded">2020-10-06T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>외부 레이어</h3><div class="text-muted small"><p> Layer를 이용한 유연성 확보 Poky는 방대한 양의 Meta-data를 가진다. Machine configuration file, class, 간단한 application 화면을 구성하는 Stack들 Framework Bitbake는 다양한 곳에서 Meta-da...</p></div></div></a></div><div class="card"> <a href="/posts/07BitbakeMetadata/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Sep 15, 2020 <i class="unloaded">2020-09-15T15:10:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Study summary 기록 2020-09-15</h3><div class="text-muted small"><p> 07 비트베이크 메타데이터 참고 자료 메타데이터 사용 메타 데이터는 다음과 같이 3개의 주요 영역으로 분류 Configuration(.conf) : 환경설정 파일은 전역으로 영향을 미치는 파일로 classes와 레시피의 동작을 위한 정보를 제공. Classes(.bbclass ) : 전체 시스템에서 이용할 수 있고 쉬운 유지 보수와 코드 중복을...</p></div></div></a></div><div class="card"> <a href="/posts/08YoctoProjectDev/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Oct 5, 2020 <i class="unloaded">2020-10-05T13:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Study summary 기록 2020-09-28</h3><div class="text-muted small"><p> 08 Yocto 프로젝트를 이용한 개발 소프트웨어 개발 키트란 , SDK ? 개발과 디버깅을 하기 위한 파일과 도구의 모음 툴체인이란? 소프트웨어 개발에 사용되는 프로그래밍 도구의 집합 주로 크로스 컴파일 환경을 뜻함 크로스 컴파일 환경 ? 개발환경과 실제 실행 파일이 실행되는곳의...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/external-layer/" class="btn btn-outline-primary"><p>외부 레이어</p></a> <a href="/posts/Adding-GPG-signature/" class="btn btn-outline-primary"><p>GPG Signature를 Github에 추가하자</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href=""></a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a> theme.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/writing/">Writing</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/yocto/">Yocto</a> <a class="post-tag" href="/tags/blogging/">Blogging</a> <a class="post-tag" href="/tags/memory/">memory</a> <a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/programminglanguage/">ProgrammingLanguage</a> <a class="post-tag" href="/tags/meetup/">meetup</a> <a class="post-tag" href="/tags/gcp/">gcp</a> <a class="post-tag" href="/tags/wsl2gui/">WSL2GUI</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '', 'auto'); ga('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://adas-study-group.github.io/yocto_basics/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
